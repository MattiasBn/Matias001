endereita tambem este arquivo pra que tudo seja sincronizado relembrando o next tambem precisa guardar os dados n so n laravel

"use client";

import { createContext, useContext, useState, useEffect } from "react";
import api from "@/lib/api";
import React from "react";

// --- Tipos ---
type Theme = "light" | "dark" | "system";
type FontSize = "small" | "medium" | "large";

interface Settings {
  theme: Theme;
  font_size: FontSize;
  timezone: string;
  language: string;
  email_notifications: boolean;
  push_notifications: boolean;
}

interface SettingsContextType {
  settings: Settings;
  loading: boolean;
  updateSetting: <K extends keyof Settings>(key: K, value: Settings[K]) => Promise<void>;
}

// Defaults
const INITIAL_SETTINGS_DEFAULTS: Settings = {
  theme: "system",
  font_size: "medium",
  timezone: "Africa/Luanda",
  language: "pt",
  email_notifications: true,
  push_notifications: false,
};

const LOCAL_STORAGE_KEY = "userSettings";

const SettingsContext = createContext<SettingsContextType | undefined>(undefined);

// --- Aplicadores ---
const applyTheme = (theme: Theme) => {
  if (theme === "dark") document.documentElement.classList.add("dark");
  else document.documentElement.classList.remove("dark");
};

const applyFontSize = (font_size: FontSize) => {
  document.documentElement.style.fontSize =
    font_size === "small" ? "14px" : font_size === "medium" ? "16px" : "18px";
};

// --- Provider ---
export const SettingsProvider = ({ children }: { children: React.ReactNode }) => {
  const [settings, setSettings] = useState<Settings>(INITIAL_SETTINGS_DEFAULTS);
  const [loading, setLoading] = useState(true);

  // --- 1Ô∏è‚É£ Load inicial (localStorage imediatamente, backend depois)
  useEffect(() => {
    const loadLocalSettings = () => {
      try {
        const local = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (local) {
          const parsed = JSON.parse(local);
          setSettings(parsed);
          applyTheme(parsed.theme);
          applyFontSize(parsed.font_size);
        }
      } catch {}
    };

    loadLocalSettings();

    const loadBackendSettings = async () => {
      try {
        const res = await api.get<Settings>("/settings");
        const backendSettings = { ...INITIAL_SETTINGS_DEFAULTS, ...res.data };

        setSettings(backendSettings);

        // aplica backend
        applyTheme(backendSettings.theme);
        applyFontSize(backendSettings.font_size);

        // e salva em localStorage
        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(backendSettings));
      } catch (err) {
        console.error("Erro ao carregar do backend:", err);
      } finally {
        setLoading(false);
      }
    };

    loadBackendSettings();
  }, []);

  // --- 2Ô∏è‚É£ Atualizar configura√ß√£o
  const updateSetting = async <K extends keyof Settings>(key: K, value: Settings[K]) => {
    const newSettings = { ...settings, [key]: value };

    // atualiza React state
    setSettings(newSettings);

    // salva no localStorage
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(newSettings));

    // aplica estilo
    if (key === "theme") applyTheme(value as Theme);
    if (key === "font_size") applyFontSize(value as FontSize);

    // envia ao backend
    try {
      await api.put("/settings", { [key]: value });
    } catch (err) {
      console.error("Erro ao salvar no backend:", err);
    }
  };

  return (
    <SettingsContext.Provider value={{ settings, loading, updateSetting }}>
      {children}
    </SettingsContext.Provider>
  );
};

// hook
export const useSettings = () => {
  const ctx = useContext(SettingsContext);
  if (!ctx) throw new Error("useSettings must be used within SettingsProvider");
  return ctx;
};
"use client";

import { useSettings } from "@/context/SettingsContext";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import { Button } from "@/components/ui/button";
import { ArrowLeft, Sun, Bell, Mail, Globe, Languages } from "lucide-react";
import { useRouter } from "next/navigation";
import { motion, AnimatePresence } from "framer-motion"; // üí° Importa√ß√£o de Motion

// 1. Cria um componente MotionCard baseado no seu Card existente
const MotionCard = motion(Card);

// 2. Define as variantes para a anima√ß√£o (simula√ß√£o de entrada/sa√≠da suave) ‚Äì TIPAGEM CORRIGIDA
const cardVariants = {
  initial: { opacity: 0, y: 15, scale: 0.98 },
  animate: {
    opacity: 1,
    y: 0,
    scale: 1,
    transition: {
      type: "spring" as const, // üîπ corrige o erro de tipagem
      stiffness: 120,
      damping: 15,
      duration: 0.3,
    },
  },
};

export default function SettingsPage() {
  const router = useRouter();
  const { settings, loading, updateSetting } = useSettings();

  if (loading || !settings) return <p className="p-6  text-center m-4 ">Carregando configura√ß√µes...</p>;

  const timezones = [
    { value: "Africa/Luanda", label: "Luanda (UTC+1)" },
    { value: "America/Sao_Paulo", label: "S√£o Paulo (UTC-3)" },
    { value: "Europe/Lisbon", label: "Lisboa (UTC+0)" },
    { value: "Etc/UTC", label: "UTC" },
  ];

  return (
    <div className="p-4 md:p-8 space-y-8">
      <Button variant="outline" onClick={() => router.back()} className="mb-4 flex items-center gap-2">
        <ArrowLeft className="h-4 w-4" /> Voltar
      </Button>

      <h2 className="text-3xl font-bold">Configura√ß√µes</h2>
      <p className="text-gray-500 dark:text-gray-400">Defina as prefer√™ncias do sistema.</p>

      <AnimatePresence>
        
        {/* Tema */}
        <MotionCard 
            key="tema"
            variants={cardVariants}
            initial="initial"
            animate="animate"
            transition={{ delay: 0.05 }}
        >
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Sun className="h-5 w-5" /> Tema
            </CardTitle>
            <CardDescription>Escolha o tema do sistema.</CardDescription>
          </CardHeader>
          <CardContent>
            <Select
              value={settings.theme}
              onValueChange={(value) => 
                updateSetting("theme", value as "light" | "dark" | "system")}
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Tema" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="light">Claro</SelectItem>
                <SelectItem value="dark">Escuro</SelectItem>
                <SelectItem value="system">Sistema</SelectItem>
              </SelectContent>
            </Select>
          </CardContent>
        </MotionCard>

        {/* Linguagem */}
        <MotionCard
            key="idioma"
            variants={cardVariants}
            initial="initial"
            animate="animate"
            transition={{ delay: 0.1 }}
        >
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Languages className="h-5 w-5" /> Idioma
            </CardTitle>
          </CardHeader>
          <CardContent>
            <Select
              value={settings.language}
              onValueChange={(v) => updateSetting("language", v)}
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Idioma" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="pt">Portugu√™s</SelectItem>
                <SelectItem value="en">Ingl√™s</SelectItem>
                <SelectItem value="es">Espanhol</SelectItem>
                <SelectItem value="fr">Franc√™s</SelectItem>
              </SelectContent>
            </Select>
          </CardContent>
        </MotionCard>

        {/* Tamanho da Fonte */}
        <MotionCard
            key="tamanho_fonte"
            variants={cardVariants}
            initial="initial"
            animate="animate"
            transition={{ delay: 0.15 }}
        >
          <CardHeader>
            <CardTitle>Tamanho da Letra</CardTitle>
            <CardDescription>Define o tamanho global da fonte.</CardDescription>
          </CardHeader>
          <CardContent className="flex gap-3">
            <Button variant={settings.font_size === "small" ? "default" : "ghost"} onClick={() => updateSetting("font_size", "small")}>
              Pequeno
            </Button>

            <Button variant={settings.font_size === "medium" ? "default" : "ghost"} onClick={() => updateSetting("font_size", "medium")}>
              M√©dio
            </Button>

            <Button variant={settings.font_size === "large" ? "default" : "ghost"} onClick={() => updateSetting("font_size", "large")}>
              Grande
            </Button>
          </CardContent>
        </MotionCard>

        {/* Notifica√ß√µes */}
        <MotionCard
            key="notificacoes"
            variants={cardVariants}
            initial="initial"
            animate="animate"
            transition={{ delay: 0.2 }}
        >
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Bell className="h-5 w-5" /> Notifica√ß√µes
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="flex justify-between">
              <Label className="flex items-center gap-2">
                <Mail className="h-4 w-4" /> Email
              </Label>
              <Switch
                checked={settings.email_notifications}
                onCheckedChange={(v) => updateSetting("email_notifications", v)}
              />
            </div>

            <Separator />

            <div className="flex justify-between">
              <Label>Push</Label>
              <Switch
                checked={settings.push_notifications}
                onCheckedChange={(v) => updateSetting("push_notifications", v)}
              />
            </div>
          </CardContent>
        </MotionCard>

        {/* Timezone */}
        <MotionCard
            key="fuso_horario"
            variants={cardVariants}
            initial="initial"
            animate="animate"
            transition={{ delay: 0.25 }}
        >
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Globe className="h-5 w-5" /> Fuso hor√°rio
            </CardTitle>
          </CardHeader>
          <CardContent>
            <Select
              value={settings.timezone}
              onValueChange={(v) => updateSetting("timezone", v)}
            >
              <SelectTrigger className="w-[250px]">
                <SelectValue placeholder="Selecione o fuso hor√°rio" />
              </SelectTrigger>

              <SelectContent>
                {timezones.map((tz) => (
                  <SelectItem value={tz.value} key={tz.value}>
                    {tz.label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </CardContent>
        </MotionCard>
      </AnimatePresence>
    </div>
  );
}
, n quero q depois de nos fizermos tudo isso n funcijone,j vou te mandar tambem o meu auth context pra vc se basear la em algumas coisas pra n criar conflitos nos arquivos 

"use client";

import {
  createContext,
  useState,
  useEffect,
  useContext,
  ReactNode,
  useCallback,
} from "react";
import { useRouter, usePathname } from "next/navigation";
import { useCookies } from "next-client-cookies";
import { AxiosError } from "axios";
import api from "@/lib/api";
import { User, MeResponse } from "@/types/api";
import Loader from "@/components/animacao/Loader";

// -----------------------------------------------------------
// TIPAGEM DO CONTEXTO
// -----------------------------------------------------------
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (token: string, userData: User) => Promise<void>;
  logout: () => Promise<void>;
  loading: boolean;
  fetchLoggedUser: (tokenOverride?: string) => Promise<void>;
  loginWithGoogle: () => Promise<void>;
  registerWithGoogle: () => Promise<void>;
  googleMessage: { code: string; message: string } | null;
  clearGoogleMessage: () => void;
}

// -----------------------------------------------------------
// CONTEXTO
// -----------------------------------------------------------
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// -----------------------------------------------------------
// FUN√á√ÉO AUXILIAR ‚Äî normaliza tokens armazenados
// -----------------------------------------------------------
const normalizeStoredToken = (t: string | null | undefined) => {
  if (!t) return null;
  const s = String(t).trim();
  if (s === "" || s === "null" || s === "undefined") return null;
  return s;
};

// -----------------------------------------------------------
// PROVIDER
// -----------------------------------------------------------
export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [googleMessage, setGoogleMessage] = useState<{ code: string; message: string } | null>(null);

  const router = useRouter();
  const pathname = usePathname();
  const cookies = useCookies();

  // -----------------------------------------------------------
  // Define header Authorization globalmente
  // -----------------------------------------------------------
  const setApiToken = useCallback((token: string | null) => {
    if (typeof window === "undefined") return;
    if (token && token !== "undefined") {
      api.defaults.headers.common["Authorization"] = `Bearer ${token}`;
    } else {
      delete api.defaults.headers.common["Authorization"];
    }
  }, []);

  const clearGoogleMessage = useCallback(() => setGoogleMessage(null), []);

  // -----------------------------------------------------------
  // LOGOUT
  // -----------------------------------------------------------
  const logout = useCallback(async () => {
    try {
      const tokenFromStorage = normalizeStoredToken(
        localStorage.getItem("token") || cookies.get("token")
      );
      if (tokenFromStorage) {
        await api.post(
          "/logout",
          {},
          { headers: { Authorization: `Bearer ${tokenFromStorage}` } }
        );
      }
    } catch {
      // ignora erro
    } finally {
      cookies.remove("token", { path: "/" });
      localStorage.removeItem("token");
      localStorage.removeItem("user");
      setUser(null);
      setApiToken(null);
      router.replace("/login");
    }
  }, [cookies, router, setApiToken]);

  // -----------------------------------------------------------
  // FETCH LOGGED USER
  // -----------------------------------------------------------
  const fetchLoggedUser = useCallback(
    async (tokenOverride?: string) => {
      setLoading(true);
      const token =
        normalizeStoredToken(tokenOverride) ||
        normalizeStoredToken(localStorage.getItem("token")) ||
        normalizeStoredToken(cookies.get("token"));

      if (!token) {
        setUser(null);
        setLoading(false);
        return;
      }

      setApiToken(token);

      try {
        const { data } = await api.get<MeResponse>("/me", {
          headers: { Authorization: `Bearer ${token}` },
        });

        setUser(data);
        localStorage.setItem("user", JSON.stringify(data));

        if (!data.confirmar) {
          await logout();
          router.replace("/login?status_code=PENDING_APPROVAL");
          return;
        }

        if (
          ["/", "/login", "/register"].includes(pathname)
        ) {
          const rolePath: Record<string, string> = {
            administrador: "/dashboard/admin",
            funcionario: "/dashboard/funcionario",
            gerente: "/dashboard/gerente",
          };
          router.replace(rolePath[data.role] || "/dashboard");
        }
      } catch (error) {
        if (error instanceof AxiosError && error.response?.status === 401) {
          await logout();
        } else {
          console.error("fetchLoggedUser error:", error);
        }
      } finally {
        setLoading(false);
      }
    },
    [cookies, pathname, router, logout, setApiToken]
  );

  // -----------------------------------------------------------
  // LOGIN NORMAL
  // -----------------------------------------------------------
  const login = useCallback(
    async (token: string, userData: User) => {
      if (!token) return;

      const expirationDate = new Date();
      expirationDate.setDate(expirationDate.getDate() + 7);

      cookies.set("token", token, { path: "/", expires: expirationDate });
      localStorage.setItem("token", token);
      setApiToken(token);
      setUser(userData);

      await fetchLoggedUser(token);
    },
    [cookies, fetchLoggedUser, setApiToken]
  );

  // -----------------------------------------------------------
  // LOGIN E REGISTO COM GOOGLE
  // -----------------------------------------------------------
  const loginWithGoogle = useCallback(async () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/api/auth/google/redirect?state=login`;
  }, []);

  const registerWithGoogle = useCallback(async () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/api/auth/google/redirect?state=register`;
  }, []);

  // -----------------------------------------------------------
  // CALLBACK GOOGLE
  // -----------------------------------------------------------
  useEffect(() => {
    const handleGoogleCallback = async () => {
      const params = new URLSearchParams(window.location.search);
      const tokenFromGoogle = params.get("token");
      const messageCode = params.get("message_code");

      if (window.location.search) router.replace(pathname);

      if (messageCode) {
        const messages: Record<string, string> = {
          PENDING_APPROVAL:
            "O seu registo foi criado. Aguarde a aprova√ß√£o do administrador.",
          REGISTER_PENDING_APPROVAL:
            "Aguardando aprova√ß√£o do administrador.",
        };
        setGoogleMessage({
          code: messageCode,
          message:
            messages[messageCode] || "Erro no registo social.",
        });
        router.replace("/login");
        setLoading(false);
        return;
      }

      if (tokenFromGoogle) {
        const expirationDate = new Date();
        expirationDate.setDate(expirationDate.getDate() + 7);
        cookies.set("token", tokenFromGoogle, {
          path: "/",
          expires: expirationDate,
        });
        localStorage.setItem("token", tokenFromGoogle);
        setApiToken(tokenFromGoogle);
        await fetchLoggedUser(tokenFromGoogle);
        return;
      }

      await fetchLoggedUser();
    };

    handleGoogleCallback();
  }, [cookies, fetchLoggedUser, router, pathname, setApiToken]);

  if (loading) return <Loader />;

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        login,
        logout,
        loading,
        fetchLoggedUser,
        loginWithGoogle,
        registerWithGoogle,
        googleMessage,
        clearGoogleMessage,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

// -----------------------------------------------------------
// HOOK DE USO
// -----------------------------------------------------------
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context)
    throw new Error("useAuth must be used within an AuthProvider");
  return context;
};
